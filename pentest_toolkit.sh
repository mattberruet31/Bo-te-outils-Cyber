#!/bin/bash
# Script : pentest_toolkit_dynamic.sh
# Description : Menu interactif pour extraire dynamiquement l’outil (description) et les commandes (avec titres et détails)
#              depuis le fichier Markdown docs/Couche1_Physique/cheat-couche_Physique.md.
# Auteur : [Ton Nom]
# Date : $(date +"%Y-%m-%d")
# Remarque : Ce script est destiné à des environnements de test.

LOG_FILE="pentest_report_$(date +'%Y%m%d_%H%M%S').log"
MD_FILE="docs/Couche1_Physique/cheat-couche_Physique.md"

#############################
# Fonctions d'affichage et extraction
#############################

# Extraction de la description de l'outil (tout le contenu avant "## Commandes Clés")
extract_tool_description() {
    sed '/^## Commandes Clés/,$d' "$MD_FILE"
}

# Extraction des commandes avec leur titre et description depuis "## Commandes Clés"
extract_commands_with_descriptions() {
    awk '
    BEGIN { in_section=0; in_code=0; in_details=0; title=""; code=""; details="" }
    /^## Commandes Clés/ { in_section=1; next }
    in_section {
        # Si un nouveau header de niveau 2 apparaît, on arrête.
        if ($0 ~ /^## / && $0 !~ /^## Commandes Clés/) { exit }
        # Détection du titre de commande (niveau 3)
        if ($0 ~ /^### /) {
            # Si on a déjà une commande en cours, on la sort
            if (title != "") {
                print "CMD_SEPARATOR";
                print "CMD_TITLE:" title;
                print "CMD_CODE:" code;
                print "CMD_DETAILS:" details;
            }
            title = substr($0, 5);  # Enlever "### "
            code = ""; details = "";
            in_code = 0; in_details = 0;
            next;
        }
        # Début d'un bloc de code
        if ($0 ~ /^```bash/) { in_code = 1; next }
        # Fin d'un bloc de code
        if ($0 ~ /^```/ && in_code) { in_code = 0; next }
        if (in_code) {
            code = code $0 "\n";
            next;
        }
        # Début de la section détails (on s'attend à "*Détails :" ou "Détails :" )
        if ($0 ~ /^\*Détails :\*/ || $0 ~ /^Détails :/) { in_details = 1; next }
        # Si on est dans la section détails, on capture jusqu'à une ligne vide
        if (in_details) {
            if ($0 ~ /^[[:space:]]*$/) { in_details = 0; next }
            details = details $0 "\n";
            next;
        }
    }
    END {
        if (title != "") {
            print "CMD_SEPARATOR";
            print "CMD_TITLE:" title;
            print "CMD_CODE:" code;
            print "CMD_DETAILS:" details;
        }
    }
    ' "$MD_FILE"
}

# Fonction de log
log_action() {
    echo "$(date +'%Y-%m-%d %H:%M:%S') - $1" >> "$LOG_FILE"
}

# Fonction de confirmation
confirm_execution() {
    echo -n "Voulez-vous exécuter cette commande ? [o/n] : "
    read confirmation
    if [[ "$confirmation" =~ ^[oO]$ ]]; then
        return 0
    else
        return 1
    fi
}

#############################
# Affichage du menu pour l'outil et sélection de commande
#############################

execute_couche_physique_dynamic() {
    if [ ! -f "$MD_FILE" ]; then
        echo "Le fichier $MD_FILE n'existe pas !"
        exit 1
    fi

    clear
    echo "=========================================="
    echo "Outil disponible :"
    # Affichage de la description de l'outil
    extract_tool_description
    echo "=========================================="
    echo "Appuyez sur Entrée pour voir la liste des commandes..."
    read

    # Extraction des commandes avec descriptions dans un tableau
    local raw
    raw=$(extract_commands_with_descriptions)
    # On va lire ligne par ligne et regrouper chaque commande
    declare -a cmd_titles
    declare -a cmd_codes
    declare -a cmd_details
    local current_title=""
    local current_code=""
    local current_details=""
    while IFS= read -r line; do
        if [[ "$line" == "CMD_SEPARATOR" ]]; then
            if [ -n "$current_title" ]; then
                cmd_titles+=("$current_title")
                cmd_codes+=("$current_code")
                cmd_details+=("$current_details")
                current_title=""; current_code=""; current_details=""
            fi
        elif [[ "$line" == CMD_TITLE:* ]]; then
            current_title="${line#CMD_TITLE:}"
        elif [[ "$line" == CMD_CODE:* ]]; then
            current_code="${line#CMD_CODE:}"
        elif [[ "$line" == CMD_DETAILS:* ]]; then
            current_details="${line#CMD_DETAILS:}"
        fi
    done <<< "$raw"
    # Si la dernière commande n'a pas été ajoutée
    if [ -n "$current_title" ]; then
        cmd_titles+=("$current_title")
        cmd_codes+=("$current_code")
        cmd_details+=("$current_details")
    fi

    # Vérifier qu'on a des commandes
    if [ ${#cmd_titles[@]} -eq 0 ]; then
        echo "Aucune commande trouvée dans $MD_FILE."
        return
    fi

    # Afficher le menu des commandes
    echo "Commandes disponibles (extraites de $MD_FILE) :"
    for i in "${!cmd_titles[@]}"; do
        printf "%d) %s\n" $((i+1)) "${cmd_titles[$i]}"
        echo "   Description :"
        echo "   $(echo "${cmd_details[$i]}" | head -n 2)"  # Afficher les 2 premières lignes des détails
        echo "------------------------------------------"
    done

    echo -n "Sélectionnez le numéro de la commande à exécuter (ou 0 pour annuler) : "
    read choice
    if ! [[ "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -le 0 ] || [ "$choice" -gt "${#cmd_titles[@]}" ]; then
        echo "Annulation ou choix invalide."
        log_action "Aucune commande exécutée dans la couche physique."
        return
    fi

    local index=$((choice-1))
    echo "Commande sélectionnée :"
    echo "Titre : ${cmd_titles[$index]}"
    echo "Commande :"
    echo "--------------------------------"
    echo "${cmd_codes[$index]}"
    echo "--------------------------------"
    echo "Description complète :"
    echo "${cmd_details[$index]}"
    echo "--------------------------------"
    log_action "Sélectionné la commande '${cmd_titles[$index]}'"
    if confirm_execution; then
        log_action "Exécution de la commande '${cmd_titles[$index]}'"
        eval "${cmd_codes[$index]}"
    else
        log_action "Commande affichée mais non exécutée."
    fi
    echo -n "Appuyez sur Entrée pour continuer..."
    read
}

#############################
# Menu principal
#############################

while true; do
    clear
    echo "=========================================="
    echo "1. Afficher et exécuter une commande depuis $MD_FILE"
    echo "2. Générer le rapport final"
    echo "3. Quitter"
    echo "=========================================="
    echo -n "Votre choix : "
    read main_choice
    case $main_choice in
        1) execute_couche_physique_dynamic ;;
        2)
            echo "Génération du rapport final..."
            {
                echo "# Rapport d'activité du Pentest Toolkit"
                echo "Date : $(date)"
                echo "-----------------------------------------"
                cat "$LOG_FILE"
            } > rapport_final.md
            echo "Rapport généré dans rapport_final.md"
            log_action "Rapport final généré."
            echo -n "Appuyez sur Entrée pour continuer..."
            read
            ;;
        3) echo "Au revoir !"; exit 0 ;;
        *) echo "Option invalide."; sleep 1 ;;
    esac
done
