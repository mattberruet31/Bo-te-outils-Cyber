#!/bin/bash
# Script : pentest_toolkit_hier.sh
# Description : Menu interactif pour sélectionner une couche (fichier Markdown) parmi plusieurs,
#              puis parcourir la structure hiérarchique (Outil → Attaque → Commande) pour exécuter des commandes.
# Auteur : [Votre Nom]
# Date : $(date +"%Y-%m-%d")
# Remarque : Le script parcourt le dossier "docs" pour lister les différentes couches.
#            Chaque dossier de couche doit contenir un fichier .md dont le nom commence par "cheat-couche_".

BASE_DIR="docs"
MD_FILE=""
LOG_FILE="pentest_report_$(date +'%Y%m%d_%H%M%S').log"

# Fonction de log
log_action() {
    echo "$(date +'%Y-%m-%d %H:%M:%S') - $1" >> "$LOG_FILE"
}

# Fonction de confirmation
confirm_execution() {
    echo -n "Voulez-vous exécuter cette commande ? [o/n] : "
    read confirmation
    if [[ "$confirmation" =~ ^[oO]$ ]]; then
        return 0
    else
        return 1
    fi
}

##################################
# Sélection de la couche
##################################
select_layer() {
    echo "Couches disponibles :"
    layers=()
    index=1
    # On liste tous les dossiers dans BASE_DIR qui commencent par "Couche"
    for dir in "$BASE_DIR"/Couche*; do
        if [ -d "$dir" ]; then
            layers+=("$dir")
            # Afficher le nom du dossier sans le chemin "docs/"
            printf "%d) %s\n" "$index" "$(basename "$dir")"
            ((index++))
        fi
    done

    if [ ${#layers[@]} -eq 0 ]; then
        echo "Aucune couche trouvée dans $BASE_DIR."
        exit 1
    fi

    echo -n "Choisissez une couche (numéro) : "
    read layer_choice
    if ! [[ "$layer_choice" =~ ^[0-9]+$ ]] || [ "$layer_choice" -lt 1 ] || [ "$layer_choice" -gt "${#layers[@]}" ]; then
        echo "Choix invalide."
        exit 1
    fi
    selected_layer="${layers[$((layer_choice-1))]}"
    log_action "Couche sélectionnée : $(basename "$selected_layer")"
    
    # On suppose que dans chaque dossier, il y a un fichier .md commençant par "cheat-couche_"
    MD_FILE=$(find "$selected_layer" -maxdepth 1 -type f -name "cheat-couche_*.md" | head -n 1)
    if [ -z "$MD_FILE" ]; then
        echo "Aucun fichier Markdown trouvé dans $selected_layer."
        exit 1
    fi
}

##################################
# Sélection d'un outil dans le fichier Markdown (lignes commençant par "### Outil:")
select_tool() {
    echo "Outils disponibles dans la couche $(basename "$selected_layer") :"
    tools=()
    index=1
    while IFS= read -r line; do
        tool_name=$(echo "$line" | sed 's/^### Outil:[[:space:]]*//')
        tools+=("$tool_name")
        printf "%d) %s\n" "$index" "$tool_name"
        ((index++))
    done < <(grep '^### Outil:' "$MD_FILE")
    
    if [ ${#tools[@]} -eq 0 ]; then
        echo "Aucun outil trouvé dans $MD_FILE."
        exit 1
    fi
    
    echo -n "Choisissez un outil (numéro) : "
    read tool_choice
    if ! [[ "$tool_choice" =~ ^[0-9]+$ ]] || [ "$tool_choice" -lt 1 ] || [ "$tool_choice" -gt "${#tools[@]}" ]; then
        echo "Choix invalide."
        exit 1
    fi
    selected_tool="${tools[$((tool_choice-1))]}"
    log_action "Outil sélectionné : $selected_tool"
    
    # Extraire le bloc correspondant à l'outil choisi (de "### Outil:" à la prochaine "### Outil:" ou fin de fichier)
    tool_block=$(sed -n "/^### Outil:[[:space:]]*$selected_tool/,/^### Outil:/p" "$MD_FILE")
}

##################################
# Sélection d'une attaque dans le bloc de l'outil (lignes commençant par "#### Attaque:")
select_attack() {
    echo "Attaques disponibles pour l'outil '$selected_tool' :"
    attacks=()
    index=1
    while IFS= read -r line; do
        attack_name=$(echo "$line" | sed 's/^#### Attaque:[[:space:]]*//')
        attacks+=("$attack_name")
        printf "%d) %s\n" "$index" "$attack_name"
        ((index++))
    done < <(echo "$tool_block" | grep '^#### Attaque:')
    
    if [ ${#attacks[@]} -eq 0 ]; then
        echo "Aucune attaque trouvée pour l'outil '$selected_tool'."
        exit 1
    fi
    
    echo -n "Choisissez une attaque (numéro) : "
    read attack_choice
    if ! [[ "$attack_choice" =~ ^[0-9]+$ ]] || [ "$attack_choice" -lt 1 ] || [ "$attack_choice" -gt "${#attacks[@]}" ]; then
        echo "Choix invalide."
        exit 1
    fi
    selected_attack="${attacks[$((attack_choice-1))]}"
    log_action "Attaque sélectionnée : $selected_attack"
    
    # Extraire le bloc d'attaque (de "#### Attaque:" à la prochaine "#### Attaque:" ou fin du bloc outil)
    attack_block=$(echo "$tool_block" | sed -n "/^#### Attaque:[[:space:]]*$selected_attack/,/^\(#### Attaque:\|### Outil:\|# \)/p")
}

##################################
# Sélection d'une commande dans le bloc de l'attaque (lignes commençant par "###### Commande:")
select_command() {
    echo "Commandes disponibles pour l'attaque '$selected_attack' :"
    commands=()
    titles=()
    index=1
    while IFS= read -r line; do
        cmd_title=$(echo "$line" | sed 's/^###### Commande:[[:space:]]*//')
        if [ -n "$cmd_title" ]; then
            titles+=("$cmd_title")
            printf "%d) %s\n" "$index" "$cmd_title"
            ((index++))
        fi
    done < <(echo "$attack_block" | grep '^###### Commande:')
    
    if [ ${#titles[@]} -eq 0 ]; then
        echo "Aucune commande trouvée pour l'attaque '$selected_attack'."
        exit 1
    fi
    
    echo -n "Choisissez une commande (numéro) : "
    read cmd_choice
    if ! [[ "$cmd_choice" =~ ^[0-9]+$ ]] || [ "$cmd_choice" -lt 1 ] || [ "$cmd_choice" -gt "${#titles[@]}" ]; then
        echo "Choix invalide."
        exit 1
    fi
    selected_cmd_title="${titles[$((cmd_choice-1))]}"
    log_action "Commande sélectionnée : $selected_cmd_title"
    
    # Extraire le bloc de commande (de "###### Commande:" jusqu'au prochain "###### Commande:" ou fin du bloc d'attaque)
    cmd_block=$(echo "$attack_block" | sed -n "/^###### Commande:[[:space:]]*$selected_cmd_title/,/^\(###### Commande:\|#### \|### \|# \)/p")
    
    # Extraction du code entre ```bash et ```
    code=$(echo "$cmd_block" | sed -n '/^```bash/,/^```/p' | sed '1d;$d')
    # Extraction des détails : tout ce qui suit la ligne "Détails :" jusqu'à la fin du bloc
    details=$(echo "$cmd_block" | sed -n '/^Détails :/,$p' | sed '1d')
    
    echo "Commande à exécuter :"
    echo "Titre: $selected_cmd_title"
    echo "--------------------------------"
    echo "$code"
    echo "--------------------------------"
    echo "Détails :"
    echo "$details"
    echo "--------------------------------"
    
    if confirm_execution; then
        log_action "Exécution de la commande '$selected_cmd_title'"
        eval "$code"
    else
        log_action "Commande affichée mais non exécutée."
    fi
    echo -n "Appuyez sur Entrée pour continuer..."
    read
}

##################################
# Menu principal hiérarchique
##################################
while true; do
    clear
    echo "=========================================="
    echo "Pentest Toolkit"
    echo "Sélection de la Couche"
    echo "=========================================="
    echo "1. Sélectionner une couche, puis un outil, une attaque et exécuter une commande"
    echo "2. Générer le rapport final"
    echo "3. Quitter"
    echo "=========================================="
    echo -n "Votre choix : "
    read main_choice
    case $main_choice in
        1)
            select_layer
            select_tool
            select_attack
            select_command
            ;;
        2)
            echo "Génération du rapport final..."
            {
                echo "# Rapport d'activité du Pentest Toolkit"
                echo "Date : $(date)"
                echo "-----------------------------------------"
                cat "$LOG_FILE"
            } > rapport_final.md
            echo "Rapport généré dans rapport_final.md"
            log_action "Rapport final généré."
            echo -n "Appuyez sur Entrée pour continuer..."
            read
            ;;
        3)
            echo "Au revoir !"
            exit 0
            ;;
        *)
            echo "Option invalide."
            sleep 1
            ;;
    esac
done
